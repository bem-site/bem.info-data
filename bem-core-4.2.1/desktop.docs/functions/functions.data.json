{"uk":{"name":"functions","examples":[],"description":""},"ru":{"name":"functions","examples":[],"description":"<h1 id=\"functions\"><a href=\"#functions\" class=\"anchor\"></a>functions</h1>\n<p>Блок предоставляет объект, содержащий набор методов для работы с функциями JavaScript.</p>\n<h2 id=\"Обзор-3\"><a href=\"#Обзор-3\" class=\"anchor\"></a>Обзор</h2>\n<h3 id=\"Свойства-и-методы-объекта-4\"><a href=\"#Свойства-и-методы-объекта-4\" class=\"anchor\"></a>Свойства и методы объекта</h3>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>Имя</th>\n<th>Тип или возвращаемое значение</th>\n<th>Описание</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"#fields-isFunction\">isFunction</a>(<code>obj {*}</code>)</td>\n<td><code>Boolean</code></td>\n<td>Проверяет, является ли переданный аргумент функцией.</td>\n</tr>\n<tr>\n<td><a href=\"#fields-noop\">noop</a></td>\n<td><code>Function</code></td>\n<td>Пустая функция.</td>\n</tr>\n</tbody>\n</table>\n</div><h3 id=\"Элементы-блока-1\"><a href=\"#Элементы-блока-1\" class=\"anchor\"></a>Элементы блока</h3>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>Элемент</th>\n<th>Способы использования</th>\n<th>Описание</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"#elems-debounce\">debounce</a></td>\n<td><code>JS</code></td>\n<td>Декоратор функции. Объединяет несколько вызовов функции, производимых в заданном временном интервале, в один.</td>\n</tr>\n<tr>\n<td><a href=\"#elems-throttle\">throttle</a></td>\n<td><code>JS</code></td>\n<td>Декоратор функции. Ограничивает частоту выполнения функции до одного раза в указанный период.</td>\n</tr>\n</tbody>\n</table>\n</div><h3 id=\"Публичные-технологии-блока-4\"><a href=\"#Публичные-технологии-блока-4\" class=\"anchor\"></a>Публичные технологии блока</h3>\n<p>Блок реализован в технологиях:</p>\n<ul>\n<li><code>vanilla.js</code></li>\n</ul>\n<h2 id=\"Описание-3\"><a href=\"#Описание-3\" class=\"anchor\"></a>Описание</h2>\n<p><a name=\"fields\"></a></p>\n<h3 id=\"Свойства-и-методы-объекта-5\"><a href=\"#Свойства-и-методы-объекта-5\" class=\"anchor\"></a>Свойства и методы объекта</h3>\n<p><a name=\"fields-isFunction\"></a></p>\n<h4 id=\"Метод-isfunction\"><a href=\"#Метод-isfunction\" class=\"anchor\"></a>Метод <code>isFunction</code></h4>\n<p>Метод проверяет, является ли переданный аргумент функцией.  </p>\n<p><strong>Принимаемые аргументы:</strong></p>\n<ul>\n<li><code>obj {*}</code> – проверяемый объект. Обязательный аргумент.</li>\n</ul>\n<p><strong>Возвращаемое значение:</strong> <code>Boolean</code>. В случае, если аргумент является функцией – <code>true</code>.</p>\n<pre><code class=\"lang-js\">modules.require(&#39;functions&#39;, function(func) {\n    var a = function(){},\n        b = {};\n    console.log(func.isFunction(a)); // true\n    console.log(func.isFunction(b)); // false\n});\n</code></pre>\n<p><a name=\"fields-noop\"></a></p>\n<h4 id=\"Свойство-noop\"><a href=\"#Свойство-noop\" class=\"anchor\"></a>Свойство <code>noop</code></h4>\n<p>Пустая функция (<code>function() {}</code>).</p>\n<p>Не имеет аргументов и возвращаемого значения.</p>\n<p><code>noop</code> можно использовать в ситуациях, когда для работы требуется функция, но нет смысла добавлять логику. Например в качестве «заглушки» для базовых классов при проектировании в парадигме ООП.</p>\n<p>Пример:</p>\n<pre><code class=\"lang-js\">modules.define(&#39;base-class&#39;, [&#39;inherit&#39;, &#39;functions&#39;], function(provide, inherit, functions) {\n\nprovide(inherit({\n    getData : function() {\n        this._sendRequest();\n    },\n\n    _sendRequest : functions.noop\n\n}));\n\n});\n</code></pre>\n<p><a name=\"elems\"></a></p>\n<h3 id=\"Элементы-блока-2\"><a href=\"#Элементы-блока-2\" class=\"anchor\"></a>Элементы блока</h3>\n<p>Элементы блока реализуют набор декораторов функций.</p>\n<p>Декораторы добавляют функции логику, не меняя ее оригинальной сигнатуры.</p>\n<p><a name=\"elems-debounce\"></a></p>\n<h4 id=\"Элемент-debounce\"><a href=\"#Элемент-debounce\" class=\"anchor\"></a>Элемент <code>debounce</code></h4>\n<p>Декоратор, откладывающий вызовов функции до истечения задержки. После каждой попытки вызова задержка начинает отсчитываться заново.</p>\n<p><strong>Принимаемые аргументы:</strong></p>\n<ul>\n<li><code>fn {Function}</code> — оригинальная функция. Обязательный аргумент.</li>\n<li><code>timeout {Number}</code> — время задержки в миллисекундах. Обязательный аргумент.</li>\n<li>[<code>invokeAsap {Boolean}</code>] — режим работы <code>debounce</code>. По умолчанию используется первый режим (соответствует значению <code>false</code>).</li>\n<li>[<code>context {Object}</code>] — контекст для выполнения оригинальной функции.</li>\n</ul>\n<p>В зависимости от значения аргумента <code>invokeAsap</code> <code>debounce</code> может работать в двух режимах:</p>\n<ol>\n<li>Вызов оригинальной функции производится по истечению задержки после последней попытки вызова.</li>\n<li>Первый вызов оригинальной функции производится сразу же при вызове декорированной функции. Дальнейшее поведение аналогично режиму 1.</li>\n</ol>\n<p><strong>Возвращаемое значение:</strong> <code>Function</code>. Декорированная функция.</p>\n<p>Пример:</p>\n<pre><code class=\"lang-js\">modules.require(&#39;functions__debounce&#39;, function(provide, debounce) {\n\n    function log() {\n        console.log(&#39;hello!&#39;);\n    }\n\n    var debouncedLog = debounce(log, 300);\n    setInterval(debouncedLog, 50);\n\n});\n</code></pre>\n<p><a name=\"elems-throttle\"></a></p>\n<h4 id=\"Элемент-throttle\"><a href=\"#Элемент-throttle\" class=\"anchor\"></a>Элемент <code>throttle</code></h4>\n<p>Декоратор позволяет «затормозить» функцию. Она будет выполняться не чаще одного раза в указанный период, сколько бы раз в течение этого периода ни была вызвана. Все промежуточные вызовы игнорируются.</p>\n<p><strong>Принимаемые аргументы:</strong></p>\n<ul>\n<li><code>fn {Function}</code> — оригинальная функция. Обязательный аргумент.</li>\n<li><code>period {Number}</code> — интервал между вызовами в миллисекундах. Обязательный аргумент.</li>\n<li>[<code>context {Object}</code>] — контекст для выполнения оригинальной функции.</li>\n</ul>\n<p><strong>Возвращаемое значение:</strong> <code>Function</code>. Декорированная функция.</p>\n<p>Метод удобно использовать, например, для установки ресурсоемких обработчиков для часто генерируемых событий – <code>resize</code>, <code>pointermove</code> и т.п.</p>\n<p>Пример:</p>\n<pre><code class=\"lang-js\">modules.require(&#39;functions__throttle&#39;, function(provide, throttle) {\n\n    function log() {\n        console.log(&#39;hello!&#39;);\n    }\n\n    var throttledLog = throttle(log, 300);\n    setInterval(throttledLog, 50);\n\n});\n</code></pre>\n<p>В результате, функция будет выполняться не чаще чем раз в 300 миллисекунд.</p>\n"},"en":{"name":"functions","examples":[],"description":"<h1 id=\"functions-1\"><a href=\"#functions-1\" class=\"anchor\"></a>functions</h1>\n<p>This block provides an object with a set of methods for working with JavaScript functions.</p>\n<h2 id=\"overview-3\"><a href=\"#overview-3\" class=\"anchor\"></a>Overview</h2>\n<h3 id=\"properties-and-methods-of-the-object\"><a href=\"#properties-and-methods-of-the-object\" class=\"anchor\"></a>Properties and methods of the object</h3>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Type or return value</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"#fields-isFunction\">isFunction</a>(<code>obj {*}</code>)</td>\n<td><code>Boolean</code></td>\n<td>Checks whether a passed argument is a function.</td>\n</tr>\n<tr>\n<td><a href=\"#fields-noop\">noop</a></td>\n<td><code>Function</code></td>\n<td>Empty function.</td>\n</tr>\n</tbody>\n</table>\n</div><h3 id=\"elements-of-the-block-1\"><a href=\"#elements-of-the-block-1\" class=\"anchor\"></a>Elements of the block</h3>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>Element</th>\n<th>Usage</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"#elems-debounce\">debounce</a></td>\n<td><code>JS</code></td>\n<td>Function decorator that combines multiple function calls within a specified time period into one call.</td>\n</tr>\n<tr>\n<td><a href=\"#elems-throttle\">throttle</a></td>\n<td><code>JS</code></td>\n<td>Function decorator that limits the frequency of function execution to once per specified period.</td>\n</tr>\n</tbody>\n</table>\n</div><h3 id=\"public-block-technologies-4\"><a href=\"#public-block-technologies-4\" class=\"anchor\"></a>Public block technologies</h3>\n<p>The block is implemented in:</p>\n<ul>\n<li><code>vanilla.js</code></li>\n</ul>\n<h2 id=\"description-3\"><a href=\"#description-3\" class=\"anchor\"></a>Description</h2>\n<p><a name=\"fields\"></a></p>\n<h3 id=\"properties-and-methods-of-the-object-1\"><a href=\"#properties-and-methods-of-the-object-1\" class=\"anchor\"></a>Properties and methods of the object</h3>\n<p><a name=\"fields-isFunction\"></a></p>\n<h4 id=\"isfunction-method\"><a href=\"#isfunction-method\" class=\"anchor\"></a><code>isFunction</code> method</h4>\n<p>Checks whether a passed argument is a function.  </p>\n<p><strong>Accepted arguments:</strong></p>\n<ul>\n<li><code>obj {*}</code> – The object being checked. Required argument.</li>\n</ul>\n<p><strong>Return value:</strong> <code>Boolean</code>. If the argument is a function, then <code>true</code>.</p>\n<pre><code class=\"lang-js\">modules.require(&#39;functions&#39;, function(func) {\n    var a = function(){},\n        b = {};\n    console.log(func.isFunction(a)); //true\n    console.log(func.isFunction(b)); //false\n});\n</code></pre>\n<p><a name=\"fields-noop\"></a></p>\n<h4 id=\"noop-property\"><a href=\"#noop-property\" class=\"anchor\"></a><code>noop</code> property</h4>\n<p>Empty function (<code>function() {}</code>).</p>\n<p>No arguments or return value.</p>\n<p>You can use <code>noop</code> when you need a function but there isn&#39;t a reason to add the logic. For example, you can use it as a placeholder for base classes at the design stage when using OOP.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">modules.define(&#39;base-class&#39;, [&#39;inherit&#39;, &#39;functions&#39;], function(provide, inherit, functions) {\n\nprovide(inherit({\n    getData : function() {\n        this._sendRequest();\n    },\n\n    _sendRequest : functions.noop\n\n}));\n\n});\n</code></pre>\n<p><a name=\"elems\"></a></p>\n<h3 id=\"elements-of-the-block-2\"><a href=\"#elements-of-the-block-2\" class=\"anchor\"></a>Elements of the block</h3>\n<p>The block elements implement a set of function decorators.</p>\n<p>The decorators add logic to the function without changing its original signature.</p>\n<p><a name=\"elems-debounce\"></a></p>\n<h4 id=\"debounce-element\"><a href=\"#debounce-element\" class=\"anchor\"></a><code>debounce</code> element</h4>\n<p>A decorator that postpones function calls for the specified delay time. After each attempt to make a call, the delay starts over again.</p>\n<p><strong>Accepted arguments:</strong></p>\n<ul>\n<li><code>fn {Function}</code> — Original function. Required argument.</li>\n<li><code>timeout {Number}</code> — Time of delay, in milliseconds. Required argument.</li>\n<li>[<code>invokeAsap {Boolean}</code>] — The <code>debounce</code> mode. By default, the first mode is used (corresponding to the <code>false</code> value).</li>\n<li>[<code>context {Object}</code>] — The context for executing the original function.</li>\n</ul>\n<p>There are two <code>debounce</code> modes, depending on the value of <code>invokeAsap</code>:</p>\n<ol>\n<li>The original function is called when the delay expires after the last call attempt.</li>\n<li>The original function is first called as soon as the decorated function is called. After this, the behavior is the same as in the first mode.</li>\n</ol>\n<p><strong>Return value:</strong> <code>Function</code>. The decorated function.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">modules.require(&#39;functions__debounce&#39;, function(provide, debounce) {\n\n    function log() {\n        console.log(&#39;hello!&#39;);\n    }\n\n    var debouncedLog = debounce(log, 300);\n    setInterval(debouncedLog, 50);\n\n});\n</code></pre>\n<p><a name=\"elems-throttle\"></a></p>\n<h4 id=\"throttle-element\"><a href=\"#throttle-element\" class=\"anchor\"></a><code>throttle</code> element</h4>\n<p>This decorator allows you to &quot;slow down&quot; the function. It won&#39;t be executed more than once during the specified period, no matter how many times it is called during this time. All calls in the meantime are ignored.</p>\n<p><strong>Accepted arguments:</strong></p>\n<ul>\n<li><code>fn {Function}</code> — Original function. Required argument.</li>\n<li><code>period {Number}</code> — The interval between calls, in milliseconds. Required argument.</li>\n<li>[<code>context {Object}</code>] — The context for executing the original function.</li>\n</ul>\n<p><strong>Return value:</strong> <code>Function</code>. The decorated function.</p>\n<p>This method is convenient for setting resource-intensive handlers for frequently generated events, such as <code>resize</code>, <code>pointermove</code>, and so on.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">modules.require(&#39;functions__throttle&#39;, function(provide, throttle) {\n\n    function log() {\n        console.log(&#39;hello!&#39;);\n    }\n\n    var throttledLog = throttle(log, 300);\n    setInterval(throttledLog, 50);\n\n});\n</code></pre>\n<p>As a result, the function is executed no more than once every 300 milliseconds.</p>\n"}}